# QuorumPeerMain 启动过程分析

#### Vote类属性
* version:
* id: myid中的id
* zxid
* electionEpoch
* peerEpoch

#### QuorumPeer 属性
* qcm:	选举leader时的网络IO管理器
* zkDb:	数据库对象
* OBSERVER_ID:	表识observer	Long.MAX_VALUE;
* start_fle, end_fle:	fast leader election开始，结束的时间
* learnerType:	server参与类型	LearnerType.PARTICIPANT;默认参与者
* quorumPeers:	记录每个sid对应的server
* quorumConfig:	集群验证器(通常为过半验证)
* myid;	当前机器myid(sid)
* currentVote:	某一轮投票最终认定的leader
* bcVote:	向前兼容的vote，也代表认定的leader
* running:	是否不断完成leader选举以及原子广播	true;
* tickTime:	同QuorumPeerConfig中的定义
* minSessionTimeout:	同QuorumPeerConfig中的定义
* maxSessionTimeout:	同QuorumPeerConfig中的定义
* initLimit,syncLimit:	同QuorumPeerConfig中的定义
* syncEnabled:	同QuorumPeerConfig中的定义	true;
* quorumListenOnAllIPs:	同QuorumPeerConfig中的定义	false;
* tick:	当前所处的ticktime周期数
* state	server当前状态，初始为looking状态	ServerState.LOOKING;
* myQuorumAddr:	当前机器的地址
* electionType:	选举算法类型编号，对应不同的electionAlg
* electionAlg:	选举算法
* cnxnFactory:	与client进行IO
* logFactory:	事务快照日志
* quorumStats:	状态对象
* follower:	如果是following状态时，服务器对应的follower
* leader:	如果是leading状态，服务器对应的leader
* observer:	如果是observer，服务器对应的observer
* SYNC_ENABLED:	判断observer是否同步的属性名称	"zookeeper.observer.syncEnabled";
* acceptedEpoch:	接下来接收或者要成为epoch，会变动，稳定了之后就成了currentEpoch	-1;
* currentEpoch:	当前所处的epoch，是稳定的	-1;
* CURRENT_EPOCH_FILENAME:	currentEpoch对应的文件名	"currentEpoch";
* ACCEPTED_EPOCH_FILENAME:	acceptedEpoch对应的文件名	"acceptedEpoch";
* UPDATING_EPOCH_FILENAME:	updatingEpoch对应的文件名	"updatingEpoch";

#### 选举流程
参照日志，从77行开始。
1. peer初始状态=LOOKING
2. 调用election.lookForLeader（默认FastLeaderElection）<br>
    2.1. 定义recvset<Long, Vote> 记录别的节点的投票 <br>
    2.2. 初始化投票 <br>
    2.3. 先告诉别的节点，我投票给自己 <br>
    
3. 
