# QuorumPeerMain 启动过程分析

#### Vote类(选票)属性
* version:
* id: myid中的id
* zxid: 事务请求的唯一标记，由leader服务器负责进行分配。由2部分构成，高32位是peerEpoch，低32位是请求的计数，从0开始。所以由zxid我们就可以知道该请求是哪个轮次的，并且是该轮次的第几个请求。
* electionEpoch: 每执行一次leader选举，electionEpoch就会自增，用来标记leader选举的轮次
* peerEpoch: 每次leader选举完成之后，都会选举出一个新的peerEpoch，用来标记事务请求所属的轮次

#### QuorumPeer 属性
* qcm:	选举leader时的网络IO管理器
* zkDb:	数据库对象
* OBSERVER_ID:	表识observer	Long.MAX_VALUE;
* start_fle, end_fle:	fast leader election开始，结束的时间
* learnerType:	server参与类型	LearnerType.PARTICIPANT;默认参与者
* Map<Long,QuorumPeer> quorumPeers:	记录每个sid对应的server
* quorumConfig:	集群验证器(通常为过半验证)
* myid;	当前机器myid(sid)
* currentVote:	某一轮投票最终认定的leader
* bcVote:	向前兼容的vote，也代表认定的leader
* running:	是否不断完成leader选举以及原子广播	true;
* tickTime:	同QuorumPeerConfig中的定义
* minSessionTimeout:	同QuorumPeerConfig中的定义
* maxSessionTimeout:	同QuorumPeerConfig中的定义
* initLimit,syncLimit:	同QuorumPeerConfig中的定义
* syncEnabled:	同QuorumPeerConfig中的定义	true;
* quorumListenOnAllIPs:	同QuorumPeerConfig中的定义	false;
* tick:	当前所处的ticktime周期数
* state	server当前状态，初始为looking状态	ServerState.LOOKING;
* myQuorumAddr:	当前机器的地址
* electionType:	选举算法类型编号，对应不同的electionAlg
* electionAlg:	选举算法
* cnxnFactory:	与client进行IO
* logFactory:	事务快照日志
* quorumStats:	状态对象
* follower:	如果是following状态时，服务器对应的follower
* leader:	如果是leading状态，服务器对应的leader
* observer:	如果是observer，服务器对应的observer
* SYNC_ENABLED:	判断observer是否同步的属性名称	"zookeeper.observer.syncEnabled";
* acceptedEpoch:	接下来接收或者要成为epoch，会变动，稳定了之后就成了currentEpoch	-1;
* currentEpoch:	当前所处的epoch，是稳定的	-1;
* CURRENT_EPOCH_FILENAME:	currentEpoch对应的文件名	"currentEpoch";
* ACCEPTED_EPOCH_FILENAME:	acceptedEpoch对应的文件名	"acceptedEpoch";
* UPDATING_EPOCH_FILENAME:	updatingEpoch对应的文件名	"updatingEpoch";

### ServerState server所处的四种状态
* LOOKING：寻找Leader状态。当服务器处于该状态时，它会认为当前集群中没有Leader，因此需要进入Leader选举状态。
* FOLLOWING：跟随者状态。表明当前服务器角色是Follower。
* LEADING：领导者状态。表明当前服务器角色是Leader。
* OBSERVING：观察者状态。表明当前服务器角色是Observer。

### QuorumServer 记录每一个配置中server的主要信息
```java
public QuorumServer(long id, String hostname,
                    Integer port, Integer electionPort,
                    LearnerType type) {
    this.id = id;//机器的serverId
    this.hostname=hostname;//host
    if (port!=null){
        this.port=port;//选举完之后，leader和learner的通信端口
    }
    if (electionPort!=null){
        this.electionPort=electionPort;//选举之前，各server参与选举的port
    }
    if (type!=null){
        this.type = type;//server类型，为PARTICIPANT 或者 OBSERVER;
    }
    this.recreateSocketAddresses();
}
```